/* The "Standard Library" */
let true <- {#true};
let false <- {#false};
let empty <- {#empty};
let otherwise <- true;

/* IO */
let print! <- { ! s | {#print} s; };
let read! <- { ! | {#read} 0; };

/* Boolean. NOT short-circuited. */
let || <- { x y |
    cond
    | x -> true;
    | otherwise -> y;
    end;
};

let && <- { x y |
    cond
    | x -> y;
    | otherwise -> false;
    end;
};

let not <- { x |
    cond
    | x -> false;
    | otherwise -> true;
    end;
};

/* Arithmetics */
let + <- { x y | {#add} x y; };
let - <- { x y | {#sub} x y; };
let * <- { x y | {#mul} x y; };
let / <- { x y | {#fdiv} x y; };
let % <- { x y | {#mod} x y; };

/* Comparisons */
let == <- { x y | {#eq} x y; };
let > <- { x y | {#gt} x y; };
let >= <- { x y |
    cond
    | x == y -> true;
    | x > y -> true;
    | otherwise -> false;
    end;
};
let < <- { x y | not (x >= y); };
let <= <- { x y | not (x > y); };

/* Bang! helpers */
let forever! <- { ! command! |
    command!;
    forever! command!;
}; 

/* List functions */
let :: <- { car cdr | {#cons} car cdr; };
let head <- { l | {#head} l; };
let tail <- { l | {#tail} l; };

let reverse_ <- { a l |
    cond
    | l == empty -> a;
    | otherwise -> reverse_ (head l :: a) (tail l);
    end;
}, reverse <- reverse_ empty;

let map <- { f l |
    cond
    | l == empty -> empty;
    | otherwise -> f (head l) :: map f (tail l);
    end;
};

let length_ <- { a l |
    cond
    | l == empty -> a;
    | otherwise -> length_ (a + 1) (tail l);
    end;
}, length <- length_ 0;

let range <- { from to |
    cond
    | from == to -> empty;
    | otherwise -> from :: range (from + 1) to;
    end;
};

let filter_ <- { a p l |
    cond
    | l == empty -> reverse a;
    | p (head l) -> filter_ (head l :: a) p (tail l);
    | otherwise -> filter_ a p (tail l);
    end;
}, filter <- filter_ empty;

let foldl <- { f a l |
    cond
    | l == empty -> a;
    | otherwise -> foldl f (f a (head l)) (tail l);
    end;
};

/* Functional helpers */
let =>> <- { v f | f v; };

let >> <- { f g x | g (f x); };

let . <- { f g x | f (g x); };

let $ <- { f v | f v; };
